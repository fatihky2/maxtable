#summary How to use the client API.
* 1. Intoduction to the client API
{{{
/* 
** Client context initialization. 
**
** Parameters:
** 	None.
** 
** Returns:
**	None.
** 
** Side Effects:
**	Allocate some memory to initialize the context for the client of Maxtable.
** 
*/
extern void
mt_cli_crt_context();

/* 
** Client context destroy. 
**
** Parameters:
**	None.
** 
** Returns:
**	None.
** 
** Side Effects:
**	Free the memory allocated by the mt_cli_crt_context();
** 
*/
extern void
mt_cli_destroy_context();


/*
** Create the connection between client and server and return the connection.
**
** Parameters:
**	meta_ip		- (IN) metaserver address.
**	meta_port	- (IN) metaserver port.
**	connection	- (OUT) the context of net connection.
** 
** Returns:
**	True if success, or false.
** 
** Side Effects
**	None
** 
*/
extern int
mt_cli_open_connection(char * meta_ip, int meta_port, conn ** connection);

/*
** Close the connection between client and server.
**
** Parameters:
**	connection	- (IN) the context of net connection.
** 
** Returns:
**	None.
** 
** Side Effects
**	None
**
*/
extern void
mt_cli_close_connection(conn * connection);


/*
** Open the context to execute the command user specified.
**
** Parameters:
**	connection	- (IN) the context of net connection.
**	cmd		- (IN) the command user specified.
**	exec_ctx		- (IN) the execution context.
** 
** Returns:
**	True if success, or false.
** 
** Side Effects
**	None
** 
*/
extern int 
mt_cli_open_execute(conn *connection, char *cmd, MT_CLI_EXEC_CONTEX *exec_ctx);


/*
** Close the execution context.
**
** Parameters:
**	exec_ctx		- (IN) the execution context.
** 
** Returns:
**	None.
** 
** Side Effects
**	None
** 
*/
extern void 
mt_cli_close_execute(MT_CLI_EXEC_CONTEX *exec_ctx);


/*
** Get the row from the execution context.
**
** Parameters:
**	exec_ctx		- (IN) the execution context.
**	rlen		- (OUT) the length of row.
** 
** Returns:
**	The pointer of the row value.
** 
** Side Effects
**	It may change the content in the execution context. 
** 
*/
extern char *
mt_cli_get_nextrow(MT_CLI_EXEC_CONTEX *exec_ctx, int *rlen);


/*
** Get the column user specified from the returned row.
**
** Parameters:
**	exec_ctx		- (IN) the execution context.
**	row_buf		- (IN) the row pointer.
**	col_idx		- (IN) the column index user specified.		
**	collen		- (OUT) the length of column.
** 
** Returns:
**	The pointer of the column value.
** 
** Side Effects
**	It may change the content in the execution context. 
** 
*/
extern char *
mt_cli_get_colvalue(MT_CLI_EXEC_CONTEX *exec_ctx, char *rowbuf, int col_idx, int *collen);
}}}


* 2. Sample code.

{{{
int main(int argc, char *argv[])
{
	conn 	*connection;
	char	resp[256], cmd[256];
	int	rtn_stat;
	int	i;
	

	if (argc != 2)
	{
		printf("Testing create table: ./sample create\n");
		printf("Testing insert table: ./sample insert\n");
		printf("Testing delete:       ./sample delete\n");
		printf("Testing select:       ./sample select\n");
		printf("Testing selectrange:  ./sample selectrange\n");
		printf("Testing selectwhere:  ./sample selectwhere\n");
		printf("Testing drop:         ./sample drop\n");

		return 0;
	}

	mt_cli_crt_context();

	MT_CLI_EXEC_CONTEX t_exec_ctx;
	MT_CLI_EXEC_CONTEX *exec_ctx = &t_exec_ctx;

	if(mt_cli_open_connection("172.16.10.11", 1959, &connection))
	{
		if (match(argv[1], "create"))
		{
			
			/* Create Table */
			memset(resp, 0, 256);
			memset(cmd , 0, 256);

			sprintf(cmd, "create table gu(id1 varchar, id2 varchar,id3 int, id4 varchar,id5 varchar,id6 varchar,id7 varchar,id8 varchar,id9 varchar)");
			mt_cli_open_execute(connection, cmd, exec_ctx);

			mt_cli_close_execute(exec_ctx);			
		}

		if (match(argv[1], "insert"))
		{
			/* Insert 10000 data rows into table */
			for(i = 1; i < 10000; i++)
			{			
				char	*c = "cccccccccccccccccccccccccccccccccccccccccccccccccccccc";
				char	*d = "dddddddddddddddddddddddddddddddddddddddddddddddddddddd";
				char	*e = "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";

				char 	*f = "ffffffffffffffffffffffffffffffffffffffffffffffffffffff";
				char	*g = "gggggggggggggggggggggggggggggggggggggggggggggggggggggg";

				char	*h = "hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh";

				sprintf(cmd, "insert into gu(aaaa%d, bbbb%d, %d, %s%d, %s%d, %s%d, %s%d, %s%d, %s%d)", i,i,i,c,i,d, i,e, i,f,i,g,i,h,i);

				//sprintf(cmd, "insert into gu(aaaa%d, bbbb%d)", i,i);
				rtn_stat = mt_cli_open_execute(connection, cmd, exec_ctx);

				if (!(rtn_stat & CLI_SUCCESS))
				{
					printf ("Error! \n");

	                                continue;
				}
				
				printf("Client 1: %s\n", cmd);

				mt_cli_close_execute(exec_ctx);
				
			}
		}

		if (match(argv[1], "selectwhere"))
		{	
			memset(resp, 0, 256);
			memset(cmd, 0, 256);
			sprintf(cmd, "selectwhere gu where id1(aaaa7, aaaa9) and id2(bbbb6, bbbb8)");
//			sprintf(cmd, "selectwhere gu where id2(bbbb3, bbbb8)");

			
			rtn_stat = mt_cli_open_execute(connection, cmd, exec_ctx);

			printf("Client 1: %s\n", cmd);

			int	rlen;
			char	*rp = NULL;

			do{
				rp = mt_cli_get_nextrow(exec_ctx, &rlen);
				
				if (rp)
				{
					int	collen = 0;				
					char	*col;
					
					col = mt_cli_get_colvalue(exec_ctx, rp, 6, &collen);

					printf ("col: %s\n", col);
				}			
			} while(rp);
			
			mt_cli_close_execute(exec_ctx);
		}
		
		if (match(argv[1], "select"))
		{
			/* Select datas from table */
			for(i = 1; i < 10000; i++)
			{
				memset(resp, 0, 256);
				memset(cmd, 0, 256);
				sprintf(cmd, "select gu(aaaa%d)", i);

				rtn_stat = mt_cli_open_execute(connection, cmd, exec_ctx);

				if (!(rtn_stat & CLI_SUCCESS))
				{
					printf ("Error! \n");

	                                continue;
				}
				
				printf("Client 1: %s\n", cmd);

				int	rlen;
				char	*rp = mt_cli_get_nextrow(exec_ctx, &rlen);

				if (rp)
				{
					int	collen = 0;
					char	*col;
					col = mt_cli_get_colvalue(exec_ctx, rp, 6, &collen);
					printf("col 6: %s\n", col);
				}
				
				mt_cli_close_execute(exec_ctx);
			
			}
		}

		if (match(argv[1], "selectrange"))
		{
			memset(resp, 0, 256);
			memset(cmd, 0, 256);
			sprintf(cmd, "selectrange gu(aaaa7, aaaa8)");

			int	row_cnt = 0;

			mt_cli_open_execute(connection, cmd, exec_ctx);

			int	rlen;
			char	*rp = NULL;
			int	collen = 0;				
			char	*col;

			while ((rp = mt_cli_get_nextrow(exec_ctx, &rlen)))
			{					
				col = mt_cli_get_colvalue(exec_ctx, rp, 6, &collen);

				printf ("row: %d, col 6: %s\n", row_cnt, col);

				row_cnt++;
			};
			
			mt_cli_close_execute(exec_ctx);
		}

	
		if (match(argv[1], "delete"))
		{

			/* Delete data in the table */
			for(i = 1; i < 100; i++)
			{
				memset(resp, 0, 256);
				memset(cmd, 0, 256);
				sprintf(cmd, "delete gu(aaaa%d)", i);
				mt_cli_open_execute(connection, cmd, exec_ctx);

				mt_cli_close_execute(exec_ctx);
			
			}

		}

		if (match(argv[1], "drop"))
		{
			memset(resp, 0, 256);
			memset(cmd, 0, 256);
			sprintf(cmd, "drop gu");
			
			mt_cli_open_execute(connection, cmd, exec_ctx);

			mt_cli_close_execute(exec_ctx);
			
		}
		
		mt_cli_close_connection(connection);
	}

	mt_cli_destroy_context();
	return 0;
}

}}}